package com.github.kaeluka.spencer.instrumentation;

import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.commons.AdviceAdapter;
import org.objectweb.asm.commons.TryCatchBlockSorter;
import org.objectweb.asm.util.CheckMethodAdapter;

import java.util.HashSet;
import java.util.function.BiConsumer;

/**
 * A method visitor that inserts source code ({@link onExit}) every time a method exits.
 * This also deals with uncaught exceptions by wrapping all instrumented methods in a
 * try catch block that executes the code generated by {@code onExit} and then rethrows 
 * he exception. For technical reasons, this class does not instrument constructors.
 *
 * @author Stephan Brandauer
 *
 */
public final class ExitHandler extends AdviceAdapter implements Opcodes {

    private final Label startTryLabel = new Label();
    private final Label endTryLabel = new Label();
    private final Label startHandlerLabel = new Label();
    private final Label endHandlerLabel = new Label();

    private final BiConsumer<ExitHandler,String> onExit;
    private int lastVisitedLine;
//	private final HashSet<Integer> exitedOnLines = new HashSet<>();

    public static MethodVisitor mk(final MethodVisitor mv, final int access,
                                   final String cName, final String mName, final String desc, final String signature,
                                   final String[] exceptions, BiConsumer<ExitHandler, String> onExit) {
        return new ExitHandler(new TryCatchBlockSorter(mv,
                access,
                mName,
                desc,
                signature,
                exceptions), access, mName, desc, signature, exceptions, onExit);
    }

    private ExitHandler(final MethodVisitor mv, final int access,
                        final String mName, final String desc, final String signature,
                        final String[] exceptions,
                        BiConsumer<ExitHandler, String> onExit) {
        super(ASM5, mv, access,
                mName, desc);
        this.onExit = onExit;
    }

    @Override
    public void visitCode() {
        super.visitCode();
        super.visitTryCatchBlock(startTryLabel, endTryLabel, endTryLabel, "java/lang/Throwable");
        super.visitLabel(startTryLabel);
    }

    @Override
    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {
        super.visitTryCatchBlock(start, end, handler, type);
    }

    @Override
    public void visitLineNumber(int line, Label start) {
        this.lastVisitedLine = line;
        super.visitLineNumber(line, start);
    }

    @Override
    public void onMethodExit(int opcode) {
        if (opcode == ATHROW) {
            //We'll catch this in the handler if needed!
            return;
        }
        this.onExit.accept(this, "normal exit - "+opcode+" "+this.lastVisitedLine);
    }

    @Override
    public void visitMaxs(final int maxStack, final int maxLocals) {
        super.visitJumpInsn(GOTO, endHandlerLabel);
        super.visitLabel(endTryLabel);
        this.onExit.accept(this, "exception being thrown");
        super.visitInsn(ATHROW);
        super.visitLabel(endHandlerLabel);
        super.visitMaxs(maxStack, maxLocals);
    }
}